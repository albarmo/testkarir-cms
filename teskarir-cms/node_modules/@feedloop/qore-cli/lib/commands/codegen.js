"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const voca_1 = tslib_1.__importDefault(require("voca"));
const prettier_1 = tslib_1.__importDefault(require("prettier"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const index_1 = tslib_1.__importDefault(require("@feedloop/qore-sdk/lib/project/index"));
const export_schema_1 = tslib_1.__importDefault(require("./export-schema"));
const flags_1 = require("../flags");
class Codegen extends command_1.Command {
    constructor() {
        super(...arguments);
        this.writeFieldTypes = new Set([
            "text",
            "number",
            "date",
            "file",
            "password",
            "select",
            "boolean",
            "select",
            "relation"
        ]);
    }
    readFieldType(field) {
        switch (field.type) {
            case "text":
            case "file":
            case "password":
                return "string";
            case "role":
                return "{id: string; displayField: string}";
            case "relation":
                if (field.multiple)
                    return `{nodes: ${voca_1.default.capitalize(field.id === "person" ? "member" : field.id)}TableRow[]}`;
                return `${voca_1.default.capitalize(field.id === "person" ? "member" : field.id)}TableRow${field.multiple ? "[]" : ""}`;
            case "rollup":
                return "number";
            case "date":
                return "Date";
            case "select":
                return field.select.map(select => `"${select}"`).join("|");
            case "lookup":
            case "formula":
                if (field.returnType === "table")
                    return "{id: string; displayField: string}";
                if (field.returnType === "text")
                    return "string";
                return field.returnType;
            default:
                return field.type;
        }
    }
    writeFieldType(field) {
        switch (field.type) {
            case "text":
            case "file":
            case "password":
            case "role":
                return "string";
            case "relation":
                return "string[]";
            case "date":
                return "Date";
            case "select":
                return field.select.map(select => `"${select}"`).join("|");
            default:
                return field.type;
        }
    }
    isWriteField(field) {
        return this.writeFieldTypes.has(field.type);
    }
    async run() {
        var _a;
        try {
            const { args, flags } = this.parse(Codegen);
            const packageJson = await fs_extra_1.default.readJson(path_1.default.resolve(process.cwd(), "package.json"));
            const configPath = flags.path || ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.qoreconfig) === null || _a === void 0 ? void 0 : _a.path) || "";
            const destination = path_1.default.resolve(process.cwd(), configPath);
            const loadedConfig = await Codegen.loadConfigFromRc(destination);
            const configs = await flags_1.promptFlags(Object.assign(Object.assign(Object.assign({}, flags), (loadedConfig || {})), { path: configPath }), Codegen.flags);
            const schema = await export_schema_1.default.getSchema(configs);
            await export_schema_1.default.run([
                "--project",
                configs.project,
                "--org",
                configs.org,
                "--token",
                configs.token,
                "--path",
                configPath
            ]);
            const idField = { id: "id", type: "text", name: "id" };
            const typeDef = `
      // ${Codegen.warningMessage}

      /// <reference types="@feedloop/qore-client" />
      import { QoreSchema } from "@feedloop/qore-client";

      declare module "@feedloop/qore-client" {
        ${schema.tables
                .map(({ id, fields }) => `
              type ${voca_1.default.capitalize(id)}TableRow = {${[idField, ...fields]
                .filter(field => field.type !== "action")
                .map(field => `
              ${field.id}: ${this.readFieldType(field)};`)
                .join("")}}`)
                .join("\n")}

        ${schema.views
                .map(({ id, parameters, sorts, fields, tableId }) => {
                const table = schema.tables.find(t => t.id === tableId);
                const getFieldType = (fieldId) => {
                    const field = table === null || table === void 0 ? void 0 : table.fields.find(field => field.id === fieldId);
                    if (!field)
                        throw new Error(`Field not found from ${table === null || table === void 0 ? void 0 : table.id}`);
                    return field;
                };
                return `
              type ${voca_1.default.capitalize(id)}ViewRow = {
                read: {${[idField, ...fields]
                    .filter(field => field.type !== "action")
                    .map(field => `
                ${field.id}: ${this.readFieldType(field)};`)
                    .join("")}}
                write: {${fields
                    .filter(vield => this.isWriteField(vield))
                    .map(field => `
                    ${field.id}: ${this.writeFieldType(field)};`)
                    .join("")}
                }
                params: {${parameters
                    .map(param => `
                    ${param.slug}${param.required ? "" : "?"}: ${param.type === "text" ? "string" : "number"};`)
                    .join("")}
                  ${sorts
                    .filter(sort => !!sort.order && !!sort.by)
                    // group order by "sort.by"
                    .reduce((group, sort) => {
                    const targetIdx = group.findIndex(sortGroup => sortGroup.by === sort.by);
                    if (group[targetIdx]) {
                        group[targetIdx].order.push(sort.order);
                    }
                    else {
                        group.push({
                            by: sort.by,
                            order: [sort.order]
                        });
                    }
                    return group;
                }, [])
                    .map(sortGroup => `"$by.${sortGroup.by}"?: ${sortGroup.order
                    .map(order => `"${order}"`)
                    .join("|")};`)
                    .join("")}
                }
                actions: {${fields
                    .filter((vield) => vield.type === "action")
                    .map(action => `${action.id}: {
                    ${action.parameters.map(param => `${param.slug}${!param.required && "?"}: ${param.type === "text" ? "string" : param.type}`)}
                  }`)}
                }
                forms: {${schema.forms
                    .filter(f => f.tableId === tableId)
                    .map(form => `
                  ${form.id}: {${form.fields.map(field => `
                        ${field.id}${field.required ? "" : "?"}: ${this.writeFieldType(getFieldType(field.id))}
                      `)}}
                `)}}
              }`;
            })
                .join("\n")}

        type ProjectSchema = {
          ${schema.views
                .map(view => `${view.id}: ${voca_1.default.capitalize(view.id)}ViewRow;`)
                .join("")}
        }
      }
    `;
            fs_1.default.writeFileSync(path_1.default.resolve(destination, "qore-env.d.ts"), prettier_1.default.format(typeDef, { parser: "babel-ts" }), {
                encoding: "utf8"
            });
            await Codegen.writeConfigFile(configs, destination);
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
}
exports.default = Codegen;
Codegen.warningMessage = "[WARNING] This file is generated by running `$ qore codegen` on your root project, please do not edit";
Codegen.description = "Generate qore project files";
Codegen.examples = [`$ qore codegen --project projectId --org orgId`];
Codegen.flags = Object.assign(Object.assign({}, flags_1.configFlags), { path: command_1.flags.string({
        name: "path",
        description: "path"
    }) });
Codegen.loadRc = async (destination) => {
    try {
        const qoreConfig = await fs_extra_1.default.readJSON(path_1.default.resolve(destination, "qore.config.json"));
        return qoreConfig;
    }
    catch (error) {
        return null;
    }
};
Codegen.loadConfigFromRc = async (destination) => {
    const rc = await Codegen.loadRc(destination);
    if (!rc)
        return null;
    return { project: rc.projectId, org: rc.organizationId };
};
Codegen.writeConfigFile = async (configs, destination) => {
    var _a;
    const project = index_1.default({
        organizationId: configs.org,
        projectId: configs.project
    });
    await project.auth.signInWithUserToken(configs.token);
    const authConfig = await project.authConfig();
    fs_extra_1.default.writeJSONSync(path_1.default.resolve(destination || process.cwd(), "qore.config.json"), {
        version: "v1",
        endpoint: "https://prod-qore-app.qorebase.io",
        projectId: configs.project,
        organizationId: configs.org,
        authenticationId: (_a = authConfig.password) === null || _a === void 0 ? void 0 : _a.id,
        WARNING: Codegen.warningMessage
    }, { spaces: 2 });
};
